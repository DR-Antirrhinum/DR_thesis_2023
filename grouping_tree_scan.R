library(dplyr)
library(matrixStats)
library(cluster)
library(dendextend)
library(zoo)
library(phangorn)

# random tree = "382.037112"

###################
#### functions ####
###################

# Run forest clustering based on cophenetic correlation coefficient
# agList = list of all UPGMA trees, clustered using agnes
# dXY = longDxy variable - a table summarising pairwise dXY across the whole genome
# seeds = a list of genomic regions to seed the clustering analysis, generated by randomising all names within agList
# cutoff = minimum cophenetic correlation coefficient for a tree to join a forest
runClustering <- function(agList, dXY, seeds, cutoff) {
  corDF <- data.frame(matrix(ncol = nrow(na.omit(dXY)), 
                             nrow = nrow(na.omit(dXY))))
  rownames(corDF) <- rownames(na.omit(dXY))
  colnames(corDF) <- rownames(na.omit(dXY))
  bootList <- list()
  #agnesList <- all_agnes
  currBin <- c()
  allBinned <- c()
  currClust <- c()
  clustList <- list()
  for(j in seeds) {
    if(!is.null(ncol(corDF))) {
      if (!j %in% allBinned){
        #print(j)
        corDF[j,] <- lapply(agList, function(x) cor(cophenetic(agList[[j]][[1]]), 
                                                    cophenetic(x[[1]])))
        currBin <- c(j, colnames(corDF[j,])[corDF[j,] > cutoff])
        currClust <- dXY[rownames(dXY) %in% currBin,]
        clustList <- append(clustList, list(currClust))
        agList <- agList[!names(agList) %in% currBin]
        corDF <- corDF[!rownames(corDF) %in% currBin,!colnames(corDF) %in% currBin]
        allBinned <- c(allBinned, currBin)
        #print(length(rownames(agnes_df)))
      }
    }
  }
  return(clustList)
}

# given a genomic coordinate, return a chromosomal interval
getInterval <- function(chr_mid_mb) {
  wg_row <- WG_off[WG_off$chromosome_midMb == as.character(chr_mid_mb),]
  chr <- wg_row$scaffold
  start <- wg_row$windowStart
  end <- wg_row$windowEnd
  interval <- paste(chr, ":", start, "-", end, sep = "")
  return(interval)
}

# given a chromosomal interval, return a genomic coordinate
getChrMidMb <- function(chr, start, end) {
  wg_row <- WG_off[WG_off$scaffold == chr & WG_off$windowStart <= start & WG_off$windowEnd >= end,]
  containing_window_mbs <- wg_row$chromosome_midMb
  return(containing_window_mbs)
}

# population info
magenta_pops <- c("ARL","ARS","BAN","MP11","MP2","PER","BED","UNA","CIN","MP4")
colour_vector_m <- rep("magenta", length(magenta_pops))
names(colour_vector_m) <- magenta_pops
yellow_pops <- c("Y-SAIG-A+B", "Y-VAU-C+D", "YP4","THU","YP1","AXA","BOU","MIJ","VIL","LU","D219","MON","YP2")
colour_vector_y <- rep("darkgoldenrod1", length(yellow_pops))
names(colour_vector_y) <- yellow_pops
white_pops <- c("D293")
colour_vector_w <- rep("white", length(white_pops))
names(colour_vector_w) <- white_pops
merged_pop_colours <- c(colour_vector_m, colour_vector_y, colour_vector_w)

# table of chromosomal offsets - see repository
lg_offsets<-read.table(paste("Chromosome_offset_tab.txt", sep = ""), header=T, sep="\t")

# point to output directory of SlidingWindows
compDir <- "/Users/richards/Desktop/Local_R_projects/paper_comparisons_V4/paper_pops_V4/"
popNames <- read.table(paste(compDir, "20pool_pop.txt", sep = ""))[,1]

popNames <- c("UNA", "BED", "LU", "AXA", "MIJ", "MON", "PER", "BOU", "VIL", "ARS", "THU", "BAN", "ARL", "CIN", "YP4", "YP2", "YP1", "MP2", "MP4", "MP11")

# SlidingWindows output files
readScaffsList <- vector("list", length = length(dir(compDir, pattern = "*OutputWindows*")))

n = 1
for(windowFile in dir(compDir, pattern = "*OutputWindows*")){
  readScaffsList[[n]] <- read.table(paste(compDir, windowFile, sep = "/"), header=T, sep="\t", fill=T)
  n = n + 1
}

# read all SlidingWindows files into genomic data table
WG <- bind_rows(readScaffsList, .id = "column_label")
Filtered_WG<-subset(WG, coverage>0.1)
WG_off<- merge(Filtered_WG, lg_offsets, by="scaffold", all.x=T)
WG_off$window_midkb<-((WG_off$windowStart+WG_off$windowEnd)/2000)
WG_off$window_midMb<-((WG_off$windowStart+WG_off$windowEnd)/2000000)
WG_off$linkage_midkb<-WG_off$window_midkb+(WG_off$offset_LG/1000)
WG_off$linkage_midMb<-WG_off$linkage_midkb/1000
WG_off$chromosome_midkb<-WG_off$window_midkb+(WG_off$offset_whole_genome/1000)
WG_off$chromosome_midMb<-WG_off$chromosome_midkb/1000

# optional filtering of populations by index
WG_pop_filtered <- WG_off
# WG_pop_filtered <- WG_pop_filtered[,grep("[A-Z|a-z|0-9]_1([_]|$)", colnames(WG_pop_filtered), invert = T)]
# WG_pop_filtered <- WG_pop_filtered[,grep("[A-Z|a-z|0-9]_2([_]|$)", colnames(WG_pop_filtered), invert = T)]
WG_pop_filtered <- WG_pop_filtered[,grep("[A-Z|a-z|0-9]_16([_]|$)", colnames(WG_pop_filtered), invert = T)]
# WG_pop_filtered <- WG_pop_filtered[,grep("[A-Z|a-z|0-9]_17([_]|$)", colnames(WG_pop_filtered), invert = T)]
WG_pop_filtered <- WG_pop_filtered[,grep("[A-Z|a-z|0-9]_18([_]|$)", colnames(WG_pop_filtered), invert = T)]
# WG_pop_filtered <- WG_pop_filtered[,grep("[A-Z|a-z|0-9]_19([_]|$)", colnames(WG_pop_filtered), invert = T)]
# WG_pop_filtered <- WG_pop_filtered[,grep("[A-Z|a-z|0-9]_19([_]|$)", colnames(WG_pop_filtered), invert = T)]
# WG_pop_filtered <- WG_pop_filtered[,grep("[A-Z|a-z|0-9]_20([_]|$)", colnames(WG_pop_filtered), invert = T)]
# WG_pop_filtered <- WG_pop_filtered[,grep("[A-Z|a-z|0-9]_21([_]|$)", colnames(WG_pop_filtered), invert = T)]
# WG_pop_filtered <- WG_pop_filtered[,grep("[A-Z|a-z|0-9]_22([_]|$)", colnames(WG_pop_filtered), invert = T)]

# generate tables summarising pi statistics across genome
longPiBar <- WG_pop_filtered[,grep("piBarAdj", colnames(WG_pop_filtered))]
rownames(longPiBar) <- WG_pop_filtered$chromosome_midMb
numbered_pop_names <- popNames
names(numbered_pop_names) <- seq(1, length(popNames))
colnames(longPiBar) <- unlist(lapply(strsplit(colnames(longPiBar), split = "_"), function(x) paste(x[1], numbered_pop_names[[x[2]]], numbered_pop_names[[x[[3]]]], sep = "_")))

longDxy <- WG_pop_filtered[,grep("dXYraw", colnames(WG_pop_filtered))]
rownames(longDxy) <- WG_pop_filtered$chromosome_midMb
numbered_pop_names <- popNames
names(numbered_pop_names) <- seq(1, length(popNames))
colnames(longDxy) <- unlist(lapply(strsplit(colnames(longDxy), split = "_"), function(x) paste(x[1], numbered_pop_names[[x[2]]], numbered_pop_names[[x[[3]]]], sep = "_")))

longFst <- WG_pop_filtered[,grep("FstfromMeanPiAdj", colnames(WG_pop_filtered))]
rownames(longFst) <- WG_pop_filtered$chromosome_midMb
numbered_pop_names <- popNames
names(numbered_pop_names) <- seq(1, length(popNames))
colnames(longFst) <- unlist(lapply(strsplit(colnames(longFst), split = "_"), function(x) paste(x[1], numbered_pop_names[[x[2]]], numbered_pop_names[[x[[3]]]], sep = "_")))

WG_dXY_variance_t <- as.data.frame(t(longDxy))
splitPops <- strsplit(as.character(rownames(WG_dXY_variance_t)), c("_"), fixed = TRUE)
tSplitPops <- t(as.data.frame(splitPops))
tSplitPops <- as.data.frame(tSplitPops[,-c(1)])
colnames(tSplitPops) <- c("Pop1", "Pop2")
UniquePops <- unique(c(paste(tSplitPops[,1]), paste(tSplitPops[,2])))
remaining_pop_colours <- merged_pop_colours[UniquePops]

all_dXY_edges <- cbind(as.data.frame(tSplitPops), as.data.frame(WG_dXY_variance_t))

# make whole genome mean dXY tree
mean_edges_df <- cbind.data.frame(all_dXY_edges[,c(1,2)], rowMeans(all_dXY_edges[,-c(1,2)], na.rm = T))
distances_df <- data.frame(matrix(nrow = length(UniquePops), ncol = length(UniquePops)))
rownames(distances_df) <- UniquePops
colnames(distances_df) <- UniquePops
distances_df[is.na(distances_df)] <- 0
for(pop in rownames(distances_df)){
  for(pop2 in rownames(distances_df)){
    if(pop != pop2){
      distances_df[pop,pop2] <- mean_edges_df[mean_edges_df$Pop1 == pop & mean_edges_df$Pop2 == pop2 | mean_edges_df$Pop1 == pop2 & mean_edges_df$Pop2 == pop,c(3)]
    }
  }
}
dend_mean_dXY  <- as.dendrogram(hclust(d = as.dist(distances_df), method = "average"))
labels_colors(dend_mean_dXY) <- remaining_pop_colours[labels(dend_mean_dXY)]
par(mfrow = c(1,1))
plot(dend_mean_dXY, main = "Whole genome mean dXY", cex.main = 2.5, ylim = c(0, 0.0115))
rect(0, 0, 19, 0.0083, lty = 2, border = "blue", lwd = 2)

# create UPGMA trees for all genomic windows
all_DMs_dXY <- list()
all_hclusts_dXY <- list()
all_agnes_dXY <- list()
for (i in rownames(na.omit(longDxy))){
  locus <- paste("\\b^", i, "$\\b", sep = "")
  edges_for_bimodal_test <- cbind.data.frame(all_dXY_edges[,c(1,2)], all_dXY_edges[,-c(1,2)][,grep(locus, colnames(all_dXY_edges)[-c(1,2)])[1]])
  window_df <- data.frame(matrix(nrow = length(UniquePops), ncol = length(UniquePops)))
  rownames(window_df) <- UniquePops
  colnames(window_df) <- UniquePops
  window_df[is.na(window_df)] <- 0
  for(pop in rownames(window_df)){
    for(pop2 in rownames(window_df)){
      if(pop != pop2){
        window_df[pop,pop2] <- edges_for_bimodal_test[edges_for_bimodal_test$Pop1 == pop & edges_for_bimodal_test$Pop2 == pop2 | edges_for_bimodal_test$Pop1 == pop2 & edges_for_bimodal_test$Pop2 == pop,c(3)]
      }
    }
  }
  all_DMs_dXY[[i]] <- window_df
  all_hclusts_dXY[[i]] <- list(hclust(as.dist(window_df), method = "average"))
  all_agnes_dXY[[i]] <- list(agnes(as.dist(window_df), method = "average"))
}

# generate summarising statistics for all genomic trees
clusterSummaries <- as.data.frame(matrix(nrow = nrow(na.omit(longDxy)), ncol = 8))
rownames(clusterSummaries) <- rownames(na.omit(longDxy))
colnames(clusterSummaries) <- c("dXY_cluster_one", "dXY_cluster_two", "dXY_tree_height", "adjusted_dXY_tree_height", "dXY_root1_length", "dXY_root2_length", "adjusted_dXY_root_length", "dXY_cophenetic_correlation")
for(window in names(all_agnes_dXY)) {
  dXY_agnes <- all_agnes_dXY[[window]][[1]]
  dXY_coph_cor <- cor(dXY_agnes[[5]], cophenetic(dXY_agnes))
  dXY_coph_mat <- as.matrix(cophenetic(dXY_agnes))
  dXY_height <- max(dXY_coph_mat)
  # Find first cluster, and count number of leaves
  dXY_clusterTwo <- max(dXY_coph_mat[dXY_coph_mat != max(dXY_coph_mat)])
  dXY_clusTwoPops <- names(apply(dXY_coph_mat, 1, function(x) dXY_clusterTwo %in% x)
                           [apply(dXY_coph_mat, 1, function(x) dXY_clusterTwo %in% x) == TRUE])
  dXY_clusOnePops <- rownames(dXY_coph_mat)[!rownames(dXY_coph_mat) %in% dXY_clusTwoPops]
  dXY_clusterOne <- max(dXY_coph_mat[rownames(dXY_coph_mat) %in% dXY_clusOnePops,colnames(dXY_coph_mat) %in% dXY_clusOnePops])
  dXY_root1 <- dXY_height - dXY_clusterOne
  dXY_root2 <- dXY_height - dXY_clusterTwo
  while(length(dXY_clusOnePops) == 1 | length(dXY_clusOnePops) == 2) {
    dXY_coph_mat <- as.data.frame(dXY_coph_mat)[!rownames(dXY_coph_mat) %in% dXY_clusOnePops, 
                                                !colnames(dXY_coph_mat) %in% dXY_clusOnePops]
    dXY_clusterOne <- max(dXY_coph_mat[dXY_coph_mat != max(dXY_coph_mat)])
    dXY_clusOnePops <- names(apply(dXY_coph_mat, 1, function(x) !dXY_clusterOne %in% x)
                             [apply(dXY_coph_mat, 1, function(x) !dXY_clusterOne %in% x) == TRUE])
    dXY_clusterTwo <- max(dXY_coph_mat[dXY_coph_mat != max(dXY_coph_mat)])
  }
  # Calculate new root length after singleton removal
  dXY_height_singletons_removed <- max(dXY_coph_mat)
  dXY_root1_singletons_removed <- dXY_height_singletons_removed - dXY_clusterOne
  dXY_root2_singletons_removed <- dXY_height_singletons_removed - dXY_clusterTwo
  dXY_rootTot_singletons_removed <- dXY_root1_singletons_removed + dXY_root2_singletons_removed
  # Find second cluster, and count number of leaves
  dXY_clusTwoPops <- rownames(dXY_coph_mat)[!rownames(dXY_coph_mat) %in% dXY_clusOnePops]
  
  # Collect summary stats
  clusterSummaries[window,] <- c(length(dXY_clusOnePops), 
                                 length(dXY_clusTwoPops), 
                                 dXY_height, 
                                 dXY_height_singletons_removed, 
                                 dXY_root1,
                                 dXY_root2,
                                 dXY_rootTot_singletons_removed, 
                                 dXY_coph_cor)

  remaining_leaves <- rownames(dXY_coph_mat)
}

############################################################
#### Grouping tree scan based on cophenetic correlation ####
############################################################

# generate a list of seed regions for the cluster analysis
clusteringSeeds <- sample(rownames(na.omit(longDxy)))

# run the clustering algorithm, to generate forests based on cophenetic correlation coefficient
dXY_clustList <- runClustering(all_agnes_dXY, longDxy, clusteringSeeds, 0.5)
dXY_filteredClustList <- dXY_clustList[as.logical(lapply(dXY_clustList, function(x) !is.null(nrow(x))))]

# generate summary statistics for all forests
dXY_forestSize <- unlist(lapply(dXY_filteredClustList, function(x) length(rownames(x))))
dXY_forestHeight <- unlist(lapply(dXY_filteredClustList, function(x) mean(clusterSummaries[rownames(x),"dXY_tree_height"], na.rm = T)))
dXY_forestRoots1 <- unlist(lapply(dXY_filteredClustList, function(x) mean(clusterSummaries[rownames(x),"dXY_root1_length"], na.rm = T)))
dXY_forestRoots2 <- unlist(lapply(dXY_filteredClustList, function(x) mean(clusterSummaries[rownames(x),"dXY_root2_length"], na.rm = T)))

dXY_forestStats <- cbind.data.frame(dXY_forestSize, dXY_forestHeight, dXY_forestRoots1, dXY_forestRoots2)

# generate mean trees for all forests
dXY_meanClustlist <- list()
namesVec <- c()
for (i in seq(1, length(dXY_filteredClustList))) {
  namesVec <- c(namesVec, i)
  temp_dXY <- cbind.data.frame(all_dXY_edges[,c(1,2)], colMeans(dXY_filteredClustList[[i]]))
  dXY_df <- data.frame(matrix(nrow = length(UniquePops), ncol = length(UniquePops)))
  rownames(dXY_df) <- UniquePops
  colnames(dXY_df) <- UniquePops
  dXY_df[is.na(dXY_df)] <- 0
  for(pop in rownames(dXY_df)){
    for(pop2 in rownames(dXY_df)){
      if(pop != pop2){
        dXY_df[pop,pop2] <- temp_dXY[temp_dXY$Pop1 == pop & temp_dXY$Pop2 == pop2 | temp_dXY$Pop1 == pop2 & temp_dXY$Pop2 == pop,c(3)]
      }
    }
  }
  dend_dXY <- as.dendrogram(hclust(as.dist(dXY_df)))
  dXY_meanClustlist[[i]] <- list(dend_dXY)
}

# forest summary plot - forest height against forest mean Shortest Root Branch (SRB)
par(mar = c(5.1, 5.1, 4.1, 2.1))
plot(dXY_forestStats$dXY_forestRoots2, dXY_forestStats$dXY_forestSize, log = "y", pch = 19,
     ylab = "Forest size", xlab = "Mean shortest first branch", cex.lab = 2)
text(dXY_forestStats$dXY_forestRoots2[order(dXY_forestStats$dXY_forestRoots2, decreasing = T)][seq(1,3)], 
     dXY_forestStats$dXY_forestSize[order(dXY_forestStats$dXY_forestRoots2, decreasing = T)][seq(1,3)], 
     adj = c(0.5,-1), labels = c("(I)", "(II)", "(III)"), col = "red")
text(dXY_forestStats$dXY_forestRoots2[order(dXY_forestStats$dXY_forestSize, decreasing = T)][1], 
     dXY_forestStats$dXY_forestSize[order(dXY_forestStats$dXY_forestSize, decreasing = T)][1], 
     adj = c(0.5,--1.5), labels = c("(A)"), col = "blue")
text(dXY_forestStats$dXY_forestRoots2[order(dXY_forestStats$dXY_forestSize, decreasing = T)][seq(2,3)], 
     dXY_forestStats$dXY_forestSize[order(dXY_forestStats$dXY_forestSize, decreasing = T)][seq(2,3)], 
     adj = c(0.5,-1), labels = c("(B)", "(C)"), col = "blue")
identify(dXY_forestStats$dXY_forestRoots2, dXY_forestStats$dXY_forestSize, log = "y")


############################################################
#### Grouping tree scan based on root division analysis ####
############################################################

# specify populations belonging to one clade of the tree topology you wish to scan for
clade_to_match <- magenta_pops[magenta_pops != c("MP2", "MP4")]

# for all subgenomic trees, use the cutree function to split into the outermost two clades
# check if either of the two clades matches clade_to_match
rda_1 <- unlist(lapply(all_hclusts_dXY, function(x) all(clade_to_match %in% names(cutree(x[[1]], 2))[as.logical(cutree(x[[1]], 2) == 1)]) & sum(as.logical(cutree(x[[1]], 2) == 1)) == length(clade_to_match)))
rda_2 <- unlist(lapply(all_hclusts_dXY, function(x) all(clade_to_match %in% names(cutree(x[[1]], 2))[as.logical(cutree(x[[1]], 2) == 2)]) & sum(as.logical(cutree(x[[1]], 2) == 1)) == length(clade_to_match)))

# all subgenomic trees matching your specific root division
matching_trees <- c(names(which(rda_1)), names(which(rda_2)))


######################################
#### bootstrap grouping tree scan ####
######################################

# N.B. bootstrapping is only applicable when grouping with cophenetic correlation coefficient

# number of bootstrap replicates
nBootstraps <- 50

# list of lists - each list contains seeds for the clustering analysis
bootstrap_seeds <- list()
for(n in seq(1, nBootstraps)) {
  bootstrap_seeds[n] <- list(sample(rownames(na.omit(longDxy))))
}

# run bootstraps, collecting the names of the trees within the most outlying forest after each replicate
dXY_bootstrapWindows <- list()
for(n in seq(1, nBootstraps)) {
  clusteringSeeds <- bootstrap_seeds[n]
  dXY_clustList <- runClustering(all_agnes_dXY, longDxy, unlist(clusteringSeeds), 0.5)
  dXY_filteredClustList <- dXY_clustList[as.logical(lapply(dXY_clustList, function(x) !is.null(nrow(x))))]
  dXY_filteredClustList <- dXY_clustList[as.logical(lapply(dXY_clustList, function(x) nrow(x) > 3))]
  forestHeights <- lapply(dXY_filteredClustList, function(x) mean(clusterSummaries[rownames(x),"dXY_root2_length"]))
  outlierForest <- which.max(forestHeights)
  forestMembers <- rownames(dXY_filteredClustList[[outlierForest]])
  print(forestMembers)
  dXY_bootstrapWindows <- append(dXY_bootstrapWindows, list(forestMembers))
}

# flatten list of results into a single list of loci
loci_dXY <- c()
for(i in dXY_bootstrapWindows) {
  loci_dXY <- c(loci_dXY, unlist((i)))
}

# optional - save results of clustering
# write(loci_dXY, "dXY_bootstrap_windows_17-5-22.txt")

